/*
 * DaSpeak Formant Synthesizer - C Implementation
 * Copyright (c) 2026 hotdogdevourer
 *
 * Licensed under the MIT License.
 * See the LICENSE file in the project root for full license information.
 */

#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <cmath>
#include <random>
#include <fstream>
#include <cstdint>
#include <algorithm>
#include <numeric>
#include <sstream>
#include <iomanip>
constexpr double M_PI=3.14159265358979323846;
namespace DaSpeakSynth{const std::set<std::string>VOWELS={"AH","AE","AA","AO","EH","EY","IH","IY","OW","UH","UW","ER"};const std::set<std::string>STOPS={"P","T","K","B","D","G","CH"};const std::set<std::string>VALID_PHONEMES={"SIL","AH","AE","AA","AO","EH","EY","IH","IY","OW","UH","UW","ER","B","D","G","P","T","K","M","N","NG","L","R","F","S","SH","TH","DH","V","Z","ZH","W","Y","HH","CH"};std::vector<double>linspace(double s,double e,int n){if(n==1)return{s};std::vector<double>r(n);double t=(e-s)/(n-1);for(int i=0;i<n;++i)r[i]=s+t*i;return r;}class IIRFilter{public:std::vector<double>b,a,z;int order;IIRFilter(const std::vector<double>&B,const std::vector<double>&A):b(B),a(A){order=std::max(b.size(),a.size())-1;z.assign(order,0.0);}double process(double x){double y=b[0]*x+z[0];for(int i=0;i<order-1;++i)z[i]=b[i+1]*x-a[i+1]*y+z[i+1];return y;}void reset(){std::fill(z.begin(),z.end(),0.0);}};std::vector<double>lfilter(const std::vector<double>&b,const std::vector<double>&a,const std::vector<double>&x){int n=x.size();std::vector<double>y(n,0.0);for(int i=0;i<n;++i){for(int k=0;k<(int)b.size()&&i-k>=0;++k)y[i]+=b[k]*x[i-k];for(int k=1;k<(int)a.size()&&i-k>=0;++k)y[i]-=a[k]*y[i-k];if(a[0]!=1.0&&a[0]!=0.0)y[i]/=a[0];}return y;}std::vector<double>filtfilt(const std::vector<double>&b,const std::vector<double>&a,const std::vector<double>&x){int p=3*(std::max(b.size(),a.size())-1);std::vector<double>z=x;if(!z.empty())for(int i=0;i<p;++i){z.insert(z.begin(),x[0]);z.push_back(x.back());}auto y=lfilter(b,a,z);std::reverse(y.begin(),y.end());y=lfilter(b,a,y);std::reverse(y.begin(),y.end());if(y.size()>2*p)y=std::vector<double>(y.begin()+p,y.end()-p);return y;}void design_butterworth(double sr,double f,const std::string&t,int o,std::vector<double>&b,std::vector<double>&a){b.clear();a.clear();double w=2*M_PI*f/sr,c=cos(w),s=sin(w),al=s/2,b0,b1,b2,a0,a1,a2;if(t=="low"){b0=(1-c)/2;b1=1-c;b2=(1-c)/2;a0=1+al;a1=-2*c;a2=1-al;}else if(t=="high"){b0=(1+c)/2;b1=-(1+c);b2=(1+c)/2;a0=1+al;a1=-2*c;a2=1-al;}else if(t=="band"){b0=al;b1=0;b2=-al;a0=1+al;a1=-2*c;a2=1-al;}else{b0=(1-c)/2;b1=1-c;b2=(1-c)/2;a0=1+al;a1=-2*c;a2=1-al;}b={b0/a0,b1/a0,b2/a0};a={1,a1/a0,a2/a0};}struct PhonemeData{double f1=0,f2=0,f3=0,f4=0,length=0.14;bool voiced=0,is_silence=0;};class Voice{public:std::string name,desc;std::map<std::string,PhonemeData>phonemes;Voice(const std::string&n,const std::string&d=""):name(n),desc(d){}PhonemeData get_phoneme_data(const std::string&p){std::string b=p;bool f=0;if(b.size()>6&&b.substr(b.size()-6)=="_FINAL"){b=b.substr(0,b.size()-6);f=1;}auto it=phonemes.find(b);if(it==phonemes.end()){auto s=phonemes.find("SIL");if(s!=phonemes.end())return s->second;return PhonemeData();}PhonemeData d=it->second;if(f&&VOWELS.count(b))d.length=std::min(d.length*1.4,0.35);return d;}};class DefaultVoice:public Voice{public:DefaultVoice():Voice("Default","Built-in robotic voice"){auto A=[&](const std::string&p,double f1,double f2,double f3,double f4,double l,bool v,bool s=0){phonemes[p]={f1,f2,f3,f4,l,v,s};};A("AH",700,1100,2400,115,0.14,1);A("AE",650,1250,2500,115,0.14,1);A("AA",620,1180,2550,115,0.14,1);A("AO",550,850,2400,115,0.14,1);A("EH",530,1700,2450,115,0.14,1);A("EY",400,2100,2800,115,0.14,1);A("IH",420,1950,2500,115,0.14,1);A("IY",300,2250,3000,115,0.14,1);A("OW",450,900,2350,115,0.14,1);A("UH",400,650,2400,115,0.14,1);A("UW",330,900,2200,115,0.14,1);A("ER",480,1180,1650,115,0.14,1);A("M",350,1050,2250,115,0.12,1);A("N",320,1150,2450,115,0.12,1);A("NG",280,950,2350,115,0.12,1);A("L",400,1150,2450,115,0.12,1);A("R",450,1250,1500,115,0.12,1);A("DH",380,1650,2450,115,0.12,1);A("V",380,1550,2450,115,0.12,1);A("Z",380,1750,2450,115,0.12,1);A("ZH",380,1450,2250,115,0.12,1);A("W",350,700,2450,115,0.12,1);A("Y",350,2050,2650,115,0.12,1);A("JH",400,1650,2450,115,0.12,1);A("B",0,0,0,0,0.068,0);A("D",0,0,0,0,0.068,0);A("G",0,0,0,0,0.068,0);A("P",0,0,0,0,0.068,0);A("T",0,0,0,0,0.068,0);A("K",0,0,0,0,0.068,0);A("F",0,0,0,0,0.125,0);A("S",0,0,0,0,0.125,0);A("SH",0,0,0,0,0.125,0);A("TH",0,0,0,0,0.125,0);A("HH",0,0,0,0,0.125,0);A("CH",0,0,0,0,0.068,0);A("SIL",0,0,0,0,0.19,0,1);}};class VoiceRegistry{public:std::map<std::string,Voice*>voices;Voice*current_voice;VoiceRegistry(){voices["Default"]=new DefaultVoice();current_voice=voices["Default"];}~VoiceRegistry(){for(auto&p:voices)delete p.second;}bool set_current_voice(const std::string&n){auto i=voices.find(n);if(i!=voices.end()){current_voice=i->second;return 1;}return 0;}};VoiceRegistry VOICE_REGISTRY;std::vector<std::string>parse_phoneme_input(const std::string&t){std::vector<std::string>p;std::istringstream i(t);std::string x;while(i>>x){std::transform(x.begin(),x.end(),x.begin(),::toupper);if(VALID_PHONEMES.count(x))p.push_back(x);else p.push_back("SIL");}if(p.empty())return{"SIL","SIL"};if(p.front()!="SIL")p.insert(p.begin(),"SIL");if(p.back()!="SIL")p.push_back("SIL");return p;}struct PhonemeSpec{std::string phoneme;double duration,overlap;std::vector<double>pitch_contour;double f1,f2,f3;bool voiced;};std::vector<PhonemeSpec>parse_phoneme_spec(const std::string&t,Voice*v){std::vector<PhonemeSpec>s;std::istringstream i(t);std::string l;while(std::getline(i,l)){l.erase(0,l.find_first_not_of(" \t"));l.erase(l.find_last_not_of(" \t")+1);if(l.empty()||l[0]=='#')continue;std::istringstream L(l);std::string p;L>>p;std::transform(p.begin(),p.end(),p.begin(),::toupper);if(!VALID_PHONEMES.count(p))continue;double d,o;L>>d>>o;std::vector<double>pc;double x;while(L>>x)pc.push_back(x);if(pc.empty())pc.push_back(0);if(pc.size()>8)pc.resize(8);d=std::max(0.01,std::min(2.0,d));o=std::max(0.0,std::min(0.5,o));PhonemeData pd=v->get_phoneme_data(p);std::set<std::string>u={"SIL","B","D","G","P","T","K","F","S","SH","TH","HH","CH"};bool vd=u.find(p)==u.end();s.push_back({p,d,o,pc,pd.f1,pd.f2,pd.f3,vd});}return s;}std::vector<PhonemeSpec>phonemes_to_spec(const std::vector<std::string>&p,Voice*v,double pb=115.0){std::vector<PhonemeSpec>s;std::set<std::string>u={"SIL","B","D","G","P","T","K","F","S","SH","TH","HH","CH"};for(size_t i=0;i<p.size();++i){const std::string&ph=p[i];PhonemeData pd=v->get_phoneme_data(ph);double d=pd.length;double o=(VOWELS.count(ph)&&i<p.size()-1)?0.05:0.025;std::vector<double>pi;if(ph=="SIL")pi={0};else if(VOWELS.count(ph)){if(i==p.size()-2)pi={pb*0.95,pb*0.9};else if(i==1)pi={pb*1.05,pb*1.1};else pi={pb};}else pi={pd.voiced?pb:0};bool vd=u.find(ph)==u.end();s.push_back({ph,d,o,pi,pd.f1,pd.f2,pd.f3,vd});}return s;}class FormantSynthesizer{private:int fs;Voice*v;double ny;int ref_fs=97000;std::mt19937 rng;std::normal_distribution<double>dist;public:FormantSynthesizer(Voice*V,int sr=97000):fs(sr),v(V),dist(0,1){ny=fs/2.0;rng.seed(42);}double scale_freq(double f){if(f<=0)return 0;double s=f*(double(fs)/ref_fs);return std::max(20.0,std::min(s,ny*0.99));}std::vector<double>generate_glottal_pulse_train_contour(double d,const std::vector<double>&pc){int n=static_cast<int>(d*fs);std::vector<double>s(n,0);double t=0;std::vector<double>p=pc;if(p.empty()||std::all_of(p.begin(),p.end(),[](double x){return x==0;}))p={115};int np=p.size();while(t<d){double tn=std::min(1.0,t/d);double f0;if(np==1)f0=p[0];else{double cp=tn*(np-1);int i=static_cast<int>(cp);double f=cp-i;if(i>=np-1)f0=p.back();else f0=p[i]*(1-f)+p[i+1]*f;}f0=std::max(50.0,std::min((fs/2.0)-500,f0));double ps=fs/f0;int pl=static_cast<int>(ps*0.6);if(pl<8)pl=8;std::vector<double>pu(pl,0);int ol=std::max(4,static_cast<int>(pl*0.4));std::vector<double>ct=linspace(0,M_PI,ol);for(int i=0;i<ol;++i)pu[i]=-0.5*(1-cos(ct[i]));if(pl>ol){int cl=pl-ol;std::vector<double>et=linspace(0,5,cl);for(int i=0;i<cl;++i)pu[ol+i]=-0.1*exp(-et[i]);}int st=static_cast<int>(t*fs),en=std::min(st+pl,n);if(en>st){int cl=std::min(pl,en-st);for(int i=0;i<cl;++i)s[st+i]+=pu[i]*0.6;}t+=ps/fs;}double pk=0;for(double x:s)pk=std::max(pk,std::abs(x));if(pk>0.1){double sc=0.6/pk;for(double&x:s)x*=sc;}return s;}std::vector<double>generate_shaped_noise(double d,const std::string&ph,double i=0.25){int n=static_cast<int>(d*fs);std::vector<double>no(n);for(int j=0;j<n;++j)no[j]=dist(rng);std::vector<double>b,a;if(ph=="S"){double lf=scale_freq(4000),hf=scale_freq(8500);design_butterworth(fs,lf,"low",2,b,a);no=lfilter(b,a,no);design_butterworth(fs,hf,"high",2,b,a);design_butterworth(fs,6500,"low",2,b,a);no=lfilter(b,a,no);for(double&x:no)x*=1.3;}else if(ph=="SH"||ph=="ZH"){double lf=scale_freq(2500),hf=scale_freq(6000);design_butterworth(fs,hf,"low",2,b,a);no=lfilter(b,a,no);}else if(ph=="F"||ph=="TH"){double cf=scale_freq(3500);design_butterworth(fs,cf,"low",2,b,a);no=lfilter(b,a,no);}else if(ph=="HH"){double cf=scale_freq(2800);design_butterworth(fs,cf,"low",2,b,a);no=lfilter(b,a,no);for(int j=0;j<n;++j)no[j]+=dist(rng)*0.15;}else if(ph=="V"||ph=="DH"||ph=="Z"){double cf=scale_freq(4500);design_butterworth(fs,cf,"low",2,b,a);no=lfilter(b,a,no);for(int j=0;j<n;++j){double vo=sin(2*M_PI*120*j/fs)*0.15;no[j]=no[j]*0.85+vo*0.15;}}else{double cf=scale_freq(7500);design_butterworth(fs,cf,"low",2,b,a);no=lfilter(b,a,no);}double pk=0;for(double x:no)pk=std::max(pk,std::abs(x));if(pk<1e-6){for(int j=0;j<n;++j)no[j]=dist(rng)*i*0.7;pk=1;}double sc=i/pk;for(double&x:no)x*=sc;if(no.size()>n)no.resize(n);return no;}std::vector<double>apply_formants_safe(const std::vector<double>&s,double f1,double f2,double f3){std::vector<double>o=s;double bw1=100,bw2=150,bw3=250;std::vector<double>b,a;auto ar=[&](double f,double bw){if(f<=50)return;double w0=2*M_PI*f/fs,sw=sin(w0),cw=cos(w0),Q=f/bw,al=sw/(2*Q),b0=sw/2,b1=0,b2=-sw/2,a0=1+al,a1=-2*cw,a2=1-al;b={b0/a0,b1/a0,b2/a0};a={1,a1/a0,a2/a0};o=lfilter(b,a,o);};if(f1>50)ar(f1,bw1);if(f2>50)ar(f2,bw2);if(f3>50)ar(f3,bw3);double pk=0;for(double x:o)pk=std::max(pk,std::abs(x));if(pk>1e-6&&pk>3){double sc=2.5/pk;for(double&x:o)x*=sc;}return o;}std::vector<double>synthesize_phoneme_direct(const PhonemeSpec&sp){std::string ph=sp.phoneme;double d=sp.duration,f1=sp.f1,f2=sp.f2,f3=sp.f3;bool vd=sp.voiced;if(ph=="SIL")return std::vector<double>(static_cast<int>(d*fs),0);if(STOPS.count(ph)){int n=static_cast<int>(d*fs);std::vector<double>o(n,0);int ce=static_cast<int>(n*0.82),bs=ce,bl=std::min(200,n-bs);if(bl>30){std::vector<double>bn(bl);for(int i=0;i<bl;++i)bn[i]=dist(rng);if(f1>50)bn=apply_formants_safe(bn,f1,f2,f3);std::vector<double>h=linspace(0,M_PI,bl);for(int i=0;i<bl;++i)bn[i]*=sin(h[i])*0.6;for(int i=0;i<bl;++i)if(bs+i<n)o[bs+i]+=bn[i];}for(double&x:o)x*=0.85;return o;}std::vector<double>out;if(!vd){double i=0.32;if(ph=="S")i=1.28;else if(ph=="SH")i=0.64;else if(ph=="F"||ph=="TH")i=0.32;std::vector<double>src=generate_shaped_noise(d,ph,i);if(f1>50){if(ph=="S"||ph=="SH")src=apply_formants_safe(src,f1*0.7,f2*0.7,f3*0.7);else src=apply_formants_safe(src,f1,f2,f3);}else for(double&x:src)x*=0.45;out=src;}else{std::vector<double>src=generate_glottal_pulse_train_contour(d,sp.pitch_contour);if(f1>50)out=apply_formants_safe(src,f1,f2,f3);else{out=src;for(double&x:out)x*=0.45;}int n=out.size();std::vector<double>env(n,1);double att=std::min(0.015,d*0.25),rel=std::min(0.03,d*0.4);int as=static_cast<int>(att*fs),rs=static_cast<int>(rel*fs);if(as>0){std::vector<double>r=linspace(0,1,as);for(int i=0;i<as&&i<n;++i)env[i]=r[i];}if(rs>0){std::vector<double>r=linspace(1,0.05,rs);for(int i=0;i<rs&&(n-1-i)>=0;++i)env[n-1-i]=r[i];}for(int i=0;i<n;++i)out[i]*=env[i];for(double&x:out)x=tanh(x*1.15)*0.93;}for(double&x:out)x*=0.82;return out;}std::vector<double>synthesize_from_specs(const std::vector<PhonemeSpec>&sp){if(sp.empty())return{};double td=0;for(const auto&s:sp)td+=s.duration;for(size_t i=0;i<sp.size()-1;++i)td-=std::min(sp[i].overlap,sp[i].duration);int ts=static_cast<int>(td*fs)+10;std::vector<double>o(ts,0);int cp=0;for(size_t i=0;i<sp.size();++i){std::vector<double>pa=synthesize_phoneme_direct(sp[i]);int ps=pa.size();double od=sp[i].overlap;if(i==sp.size()-1)od=0;int os=std::min({static_cast<int>(od*fs),ps-1,static_cast<int>(sp[i].duration*fs*0.5)});int ep=cp+ps;if(ep>o.size())o.resize(ep+1000,0);for(int k=0;k<ps;++k)if(cp+k<o.size())o[cp+k]+=pa[k];cp+=ps-os;}int al=std::min(cp,(int)o.size());std::vector<double>a(o.begin(),o.begin()+al);for(double&x:a)x=tanh(x*1.25)*0.94;double cf=scale_freq(5000);std::vector<double>b,a2;design_butterworth(fs,cf,"low",2,b,a2);a=lfilter(b,a2,a);return a;}};std::vector<uint8_t>generate_wav_bytes(const std::vector<double>&a,int sr){std::vector<int16_t>ai(a.size());for(size_t i=0;i<a.size();++i){double v=a[i]*32767;if(v>32767)v=32767;if(v<-32768)v=-32768;ai[i]=(int16_t)v;}std::vector<uint8_t>b;int nc=1,bps=16,br=sr*nc*bps/8,ba=nc*bps/8,ds=ai.size()*2;auto w32=[&](uint32_t v){b.push_back(v&0xFF);b.push_back((v>>8)&0xFF);b.push_back((v>>16)&0xFF);b.push_back((v>>24)&0xFF);};auto w16=[&](uint16_t v){b.push_back(v&0xFF);b.push_back((v>>8)&0xFF);};b.insert(b.end(),{'R','I','F','F'});w32(36+ds);b.insert(b.end(),{'W','A','V','E'});b.insert(b.end(),{'f','m','t',' '});w32(16);w16(1);w16(nc);w32(sr);w32(br);w16(ba);w16(bps);b.insert(b.end(),{'d','a','t','a'});w32(ds);for(int16_t s:ai){b.push_back(s&0xFF);b.push_back((s>>8)&0xFF);}return b;}std::vector<uint8_t>synthesize_phoneme_mode(const std::string&t,int sr=97000,Voice*vo=nullptr){if(!vo)vo=VOICE_REGISTRY.current_voice;auto p=parse_phoneme_input(t);auto sp=phonemes_to_spec(p,vo);FormantSynthesizer sy(vo,sr);auto a=sy.synthesize_from_specs(sp);return generate_wav_bytes(a,sr);}std::vector<uint8_t>synthesize_spec_mode(const std::string&t,int sr=97000,Voice*vo=nullptr){if(!vo)vo=VOICE_REGISTRY.current_voice;auto sp=parse_phoneme_spec(t,vo);FormantSynthesizer sy(vo,sr);auto a=sy.synthesize_from_specs(sp);return generate_wav_bytes(a,sr);}}int main(int argc,char*argv[]){using namespace DaSpeakSynth;std::string si,pi;double vd=0;int sr=44100;std::string of="output.wav",vn="Default";bool sh=false;for(int i=1;i<argc;++i){std::string a=argv[i];if(a=="-h"||a=="--help"){sh=true;continue;}if(a.rfind("-",0)==0&&a.find('=')!=std::string::npos){size_t e=a.find('=');std::string k=a.substr(0,e),v=a.substr(e+1);if(v.size()>=2&&((v.front()=='"'&&v.back()=='"')||(v.front()=='\''&&v.back()=='\'')))v=v.substr(1,v.size()-2);if(k=="-spec")si=v;else if(k=="-phon")pi=v;else if(k=="-v")try{vd=std::stod(v);}catch(...){std::cerr<<"Error: Invalid volume value '"<<v<<"'\n";return 1;}else if(k=="-r")try{sr=std::stoi(v);if(sr<8000||sr>192000)std::cerr<<"Warning: Sample rate "<<sr<<" Hz is outside typical range (8000-192000)\n";}catch(...){std::cerr<<"Error: Invalid sample rate '"<<v<<"'\n";return 1;}else if(k=="-o"){of=v;if(of.size()<4||of.substr(of.size()-4)!=".wav")of+=".wav";}else if(k=="-voice")vn=v;else std::cerr<<"Warning: Unknown option '"<<k<<"'\n";}else if(a.rfind("-",0)==0)std::cerr<<"Warning: Malformed option '"<<a<<"' (expected key=value)\n";else std::cerr<<"Warning: Unexpected argument '"<<a<<"'\n";}if(sh||(si.empty()&&pi.empty())){std::cout<<"DaSpeak Formant Synthesizer v1.0\nUsage: "<<argv[0]<<" [options]\n\nOptions:\n  -spec=\"<text>\"   Phoneme specifications (pipe-separated)\n                     Format: PHONEME DURATION OVERLAP PITCH...\n                     Example: \"HH 0.12 0.015 95|EH 0.14 0.018 105 110\"\n  -phon=\"<text>\"   Space-separated phoneme names\n                     Example: \"HH EH L OW\"\n  -v=<dB>          Volume adjustment in decibels (default: 0)\n  -r=<rate>        Sample rate in Hz (default: 97000)\n  -o=<file>        Output WAV filename (default: output.wav)\n  -voice=<name>    Voice preset name (default: Default)\n  -h, --help       Show this help message\n\nNote: Either -spec or -phon must be provided.\n      -spec allows fine control over duration, overlap, and pitch contour.\n      -phon uses default timing and pitch for each phoneme.\n";return sh?0:1;}if(!si.empty()&&!pi.empty()){std::cerr<<"Error: Cannot specify both -spec and -phon. Choose one.\n";return 1;}if(si.empty()&&pi.empty()){std::cerr<<"Error: Must specify either -spec or -phon.\n";return 1;}if(!VOICE_REGISTRY.set_current_voice(vn)){std::cerr<<"Warning: Voice '"<<vn<<"' not found, using Default\n";VOICE_REGISTRY.set_current_voice("Default");}Voice*vo=VOICE_REGISTRY.current_voice;std::vector<double>a;try{if(!si.empty()){auto sp=parse_phoneme_spec(si,vo);if(sp.empty()){std::cerr<<"Error: No valid phoneme specifications parsed\n";return 1;}FormantSynthesizer sy(vo,sr);a=sy.synthesize_from_specs(sp);}else{FormantSynthesizer sy(vo,sr);auto p=parse_phoneme_input(pi);auto sp=phonemes_to_spec(p,vo);a=sy.synthesize_from_specs(sp);}}catch(const std::exception&e){std::cerr<<"Synthesis error: "<<e.what()<<"\n";return 1;}if(a.empty()){std::cerr<<"Error: Synthesis produced no audio data\n";return 1;}if(vd!=0){double g=pow(10,vd/20);for(double&x:a){x*=g;x=tanh(x);}}std::vector<uint8_t>wd=generate_wav_bytes(a,sr);std::ofstream o(of,std::ios::binary);if(!o){std::cerr<<"Error: Cannot open output file '"<<of<<"'\n";return 1;}o.write(reinterpret_cast<const char*>(wd.data()),wd.size());o.close();std::cout<<"Successfully synthesized "<<a.size()<<" samples ("<<std::fixed<<std::setprecision(2)<<static_cast<double>(a.size())/sr<<" seconds)\nOutput written to: "<<of<<"\n";return 0;}
